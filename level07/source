int get_unum() {
	unsigned int ui; [ebp-0xc]
    fflush(stdout);
    __isoc99_scanf("%u", ui);
    clear_stdin();
    return ui;
}

int store_number(unsigned int *tab_number) {
	unsigned int index = 0; [ebp - 0xc]
	number = 0; [ebp - 0x10]
	int ret = 0;
    printf(" Number: ");
    number = get_unum();
    printf(" Index: ");
    index = get_unum();
	edx = 0xaaaaaaab;
	edx *= index;
	edx /= 2;
	eax = edx;
	eax *= 3;
	test = index - eax; //index % 3 ?
	if (test == 0 || number / 2^24 == 183) //if number == 3070230528 (0xB7000000)
	{
            puts(" *** ERROR! ***");
            puts("   This index is reserved for wil!");
            puts(" *** ERROR! ***");
            ret = 1;
    }
    else 
	{
		tab_number[index] = number;
    }
    return ret;
}


int read_number(unsigned int *tab_number) {
    printf(" Index: ");
    unsigned int index = get_unum();
    printf(" Number at data[%u] is %u\n", index, tab_number[index]);
    return 0;
}


int main() {
    esp = (esp & 0xfffffff0) - 0x1d0;
    asm{ rep stosd  dword [es:edi], eax };
    while (*stack[1928] != 0x0) {
            ecx = stack[1928];
            asm{ repne scasb al, byte [es:edi] };
            stack[1928] = *stack[1928];
            memset(stack[1928], 0x0, !ecx + 0xffffffff);
            *(esp + 0x1c) = *(esp + 0x1c) + 0x4;
    }
    while (*stack[1928] != 0x0) {
            ecx = stack[1928];
            asm{ repne scasb al, byte [es:edi] };
            stack[1928] = *stack[1928];
            memset(stack[1928], 0x0, !ecx + 0xffffffff);
            *(esp + 0x18) = *(esp + 0x18) + 0x4;
    }

    char *buff[20] [esp + 0x1b8];
	unsigned int *tab_number; [esp + 0x24]

    puts("----------------------------------------------------\n  Welcome to wil's crappy number storage service!   \n----------------------------------------------------\n Commands:                                          \n    store - store a number into the data sto…");
    goto loc_804884f;

loc_804884f:
    printf("Input command: ");
	mov    DWORD PTR [esp+0x1b4],0x1
    fgets(buff, 20, stdin);
	buff[strlen(buff) - 1] = 0; //sur ? pour enlever '\n' ? // avant : mov    DWORD PTR [esp+0x14],0xffffffff
	if (strcmp(buff, "store") != 0) //pluto une sorte de strcmp jusqua end
    	goto loc_80488f8;
	else
		store_number(tab_number);

loc_80488e3:
    store_number(esp + 0x24);
    goto loc_8048965;

loc_8048965:
    if (*(esp + 0x1b4) != 0x0) {
            printf(" Failed to do %s command\n", buff);
    }
    else {
            printf(" Completed %s command successfully\n", buff);
    }
	memset(buff, 0, 20); //à vérifier
    goto loc_804884f;

loc_80488f8:
    if (strcmp(buff, "read") !=0)
		goto loc_8048939;

loc_8048924:
    read_number(tab_number);
    goto loc_8048965;

loc_8048939:
    if (strcmp(buff, "quit") == 0)
    	goto loc_80489cf; //return
	else
    	goto loc_8048965;

loc_80489cf:
    eax = 0x0;
    esi = stack[1928] ^ *0x14;
    COND = esi == 0x0;
    if (!COND) {
            eax = __stack_chk_fail();
    }
    return eax;
}

